本驱动改自kesking的驱动库

# 注意修改核心接口函数

为了和i2c通信保持大致逻辑代码一致，这里就只修改了最低层的OLED_Send以及OLED_Init的实现代码。

## 驱动编写注意事项

我这里用的是telesky的oled，不同商家的oled行为可能不一致，请根据商家的实际驱动代码进行修改。

用i2c和spi其实没有什么差别，命令都是一样的。只是

### 一定要先Reset一下OLED！！！

不要以为这个reset引脚没用，实际上7个pin你都得用到。

可以对比原本的OLED_Send函数和我修改过后的OLED_Send函数，这里实际上就是加了一个Reset 100ms的代码。你可以试着把reset的代码注释掉，然后可以发现，这个OLED并没有亮起来。

### 软件SPI

我这里用的是软件SPI通信，可以说，速度已经是最快了。

这里我展示一下OLED_Send函数怎么写的：

```cpp
#define OLED_RESET_GPIO_PORT GPIOA
#define OLED_RESET_GPIO_PIN GPIO_PIN_2
#define OLED_CS_GPIO_PORT GPIOA
#define OLED_CS_GPIO_PIN GPIO_PIN_3
#define OLED_DC_GPIO_PORT GPIOA
#define OLED_DC_GPIO_PIN GPIO_PIN_4
#define OLED_CLK_GPIO_PORT GPIOA
#define OLED_CLK_GPIO_PIN GPIO_PIN_5
#define OLED_SDA_GPIO_PORT GPIOA
#define OLED_SDA_GPIO_PIN GPIO_PIN_6
#define OLED_CMD GPIO_PIN_SET   //命令声明
#define OLED_DATA GPIO_PIN_RESET //数据声明

void OLED_Send(uint8_t *data, uint8_t len)
{
  // HAL_I2C_Master_Transmit(&hi2c1, OLED_ADDRESS, data, len, HAL_MAX_DELAY);
  // 选中OLED
  HAL_GPIO_WritePin(OLED_CS_GPIO_PORT, OLED_CS_GPIO_PIN, GPIO_PIN_RESET);
  
  // 设置DC引脚
  if (data[0] == 0x00){
    HAL_GPIO_WritePin(OLED_DC_GPIO_PORT, OLED_DC_GPIO_PIN, 0);
  }
  else if (data[0] == 0x40){
    HAL_GPIO_WritePin(OLED_DC_GPIO_PORT, OLED_DC_GPIO_PIN, 1);
  }
  
  // 使用阻塞传输（更稳定）
  // HAL_SPI_Transmit(&hspi1, &data[1], len-1, HAL_MAX_DELAY);
  for (int index = 1;index < len;index++){
    uint8_t temp = data[index];
    for (int i = 0;i<8;i++){
      HAL_GPIO_WritePin(OLED_CLK_GPIO_PORT, OLED_CLK_GPIO_PIN, GPIO_PIN_RESET);
      if (temp & 0x80){
        HAL_GPIO_WritePin(OLED_SDA_GPIO_PORT, OLED_SDA_GPIO_PIN, GPIO_PIN_SET);
      }else {
        HAL_GPIO_WritePin(OLED_SDA_GPIO_PORT, OLED_SDA_GPIO_PIN, GPIO_PIN_RESET);
      }
      HAL_GPIO_WritePin(OLED_CLK_GPIO_PORT, OLED_CLK_GPIO_PIN, GPIO_PIN_SET);
      temp <<= 1;
    }
  }
  
  // 取消选中
  HAL_GPIO_WritePin(OLED_CS_GPIO_PORT, OLED_CS_GPIO_PIN, GPIO_PIN_SET);
}
```